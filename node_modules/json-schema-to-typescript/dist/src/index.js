"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationError = exports.compile = exports.compileFromFile = exports.DEFAULT_OPTIONS = void 0;
const fs_1 = require("fs");
const lodash_1 = require("lodash");
const path_1 = require("path");
const formatter_1 = require("./formatter");
const generator_1 = require("./generator");
const normalizer_1 = require("./normalizer");
const optimizer_1 = require("./optimizer");
const parser_1 = require("./parser");
const resolver_1 = require("./resolver");
const utils_1 = require("./utils");
const validator_1 = require("./validator");
const util_1 = require("util");
const linker_1 = require("./linker");
const optionValidator_1 = require("./optionValidator");
exports.DEFAULT_OPTIONS = {
    $refOptions: {},
    additionalProperties: true, // TODO: default to empty schema (as per spec) instead
    bannerComment: `/* eslint-disable */
/**
* This file was automatically generated by json-schema-to-typescript.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run json-schema-to-typescript to regenerate this file.
*/`,
    cwd: process.cwd(),
    declareExternallyReferenced: true,
    enableConstEnums: true,
    inferStringEnumKeysFromValues: false,
    format: true,
    ignoreMinAndMaxItems: false,
    maxItems: 20,
    strictIndexSignatures: false,
    style: {
        bracketSpacing: false,
        printWidth: 120,
        semi: true,
        singleQuote: false,
        tabWidth: 2,
        trailingComma: 'none',
        useTabs: false,
    },
    unreachableDefinitions: false,
    unknownAny: true,
};
function compileFromFile(filename, options = exports.DEFAULT_OPTIONS) {
    const schema = parseAsJSONSchema(filename);
    return compile(schema, (0, utils_1.stripExtension)(filename), Object.assign({ cwd: (0, path_1.dirname)(filename) }, options));
}
exports.compileFromFile = compileFromFile;
function parseAsJSONSchema(filename) {
    const contents = (0, utils_1.Try)(() => (0, fs_1.readFileSync)(filename), () => {
        throw new ReferenceError(`Unable to read file "${filename}"`);
    });
    return (0, utils_1.parseFileAsJSONSchema)(filename, contents.toString());
}
function compile(schema_1, name_1) {
    return __awaiter(this, arguments, void 0, function* (schema, name, options = {}) {
        (0, optionValidator_1.validateOptions)(options);
        const _options = (0, lodash_1.merge)({}, exports.DEFAULT_OPTIONS, options);
        const start = Date.now();
        function time() {
            return `(${Date.now() - start}ms)`;
        }
        // normalize options
        if (!(0, lodash_1.endsWith)(_options.cwd, '/')) {
            _options.cwd += '/';
        }
        // Initial clone to avoid mutating the input
        const _schema = (0, lodash_1.cloneDeep)(schema);
        const { dereferencedPaths, dereferencedSchema } = yield (0, resolver_1.dereference)(_schema, _options);
        if (process.env.VERBOSE) {
            if ((0, util_1.isDeepStrictEqual)(_schema, dereferencedSchema)) {
                (0, utils_1.log)('green', 'dereferencer', time(), '✅ No change');
            }
            else {
                (0, utils_1.log)('green', 'dereferencer', time(), '✅ Result:', dereferencedSchema);
            }
        }
        const linked = (0, linker_1.link)(dereferencedSchema);
        if (process.env.VERBOSE) {
            (0, utils_1.log)('green', 'linker', time(), '✅ No change');
        }
        const errors = (0, validator_1.validate)(linked, name);
        if (errors.length) {
            errors.forEach(_ => (0, utils_1.error)(_));
            throw new ValidationError();
        }
        if (process.env.VERBOSE) {
            (0, utils_1.log)('green', 'validator', time(), '✅ No change');
        }
        const normalized = (0, normalizer_1.normalize)(linked, dereferencedPaths, name, _options);
        (0, utils_1.log)('yellow', 'normalizer', time(), '✅ Result:', normalized);
        const parsed = (0, parser_1.parse)(normalized, _options);
        (0, utils_1.log)('blue', 'parser', time(), '✅ Result:', parsed);
        const optimized = (0, optimizer_1.optimize)(parsed, _options);
        (0, utils_1.log)('cyan', 'optimizer', time(), '✅ Result:', optimized);
        const generated = (0, generator_1.generate)(optimized, _options);
        (0, utils_1.log)('magenta', 'generator', time(), '✅ Result:', generated);
        const formatted = yield (0, formatter_1.format)(generated, _options);
        (0, utils_1.log)('white', 'formatter', time(), '✅ Result:', formatted);
        return formatted;
    });
}
exports.compile = compile;
class ValidationError extends Error {
}
exports.ValidationError = ValidationError;
//# sourceMappingURL=index.js.map